# Ligature Language Reference for LLMs

This reference is specifically designed for LLMs to quickly understand and generate Ligature code. It provides concise syntax, common patterns, and practical examples.

> **ðŸ“„ Plain Text Version**: For easier consumption by LLMs, a plain text version of this reference is available at [`/llms.txt`](/llms.txt). This file contains the same information in a format optimized for language model processing.

## Quick Start

Ligature is a **Turing-incomplete configuration language** with ML-family syntax, strong typing, and constraint-based validation. All programs terminate and are type-safe.

## Core Syntax Patterns

### 1. Basic Structure

```ocaml
// Single-line comment
/* Multi-line comment */

// Module declaration (optional)
module MyModule;

// Imports
import std.collections.list;
import "./utils" as utils;
import { add, multiply } from "./math";

// Exports
export { myFunction, MyType };
```

### 2. Value Declarations

```ocaml
// Basic value
let x = 42;

// Typed value
let name: String = "Alice";

// Function
let add = \x y -> x + y;

// Typed function
let multiply: Integer -> Integer -> Integer = \x y -> x * y;

// Recursive function
let rec factorial = \n ->
  if n == 0 then 1 else n * factorial (n - 1);
```

### 3. Types

```ocaml
// Basic types
Integer, Float, String, Boolean, Unit

// Function types
Integer -> String
Integer -> Integer -> Integer
(Integer, String) -> Boolean

// Record types
{
    name: String,
    age: Integer,
    email: String
}

// Union types
type Option = Some a | None;
type Result = Success a | Error String;

// Type aliases
type UserId = Integer;
type Point = { x: Float, y: Float };
```

### 4. Expressions

```ocaml
// Literals
42, 3.14, "hello", true, false, ()

// Variables
x, user_name

// Function application
f x
f x y
f (x, y)

// Lambda expressions
\x -> x + 1
\x y -> x + y
\x: Integer -> x * 2

// Let expressions
let x = 42 in x + 1
let x = 42; y = 10 in x + y

// If expressions
if x > 0 then "positive" else "negative"

// Match expressions
match value of
    Some x => x + 1,
    None => 0;

// Record expressions
{
    name = "Alice",
    age = 30,
    email = "alice@example.com"
}

// Field access
user.name
```

## Constraint-Based Validation

### Refinement Types

```ocaml
// Basic refinement
type PositiveInt = Integer where x > 0;

// Complex refinement
type ValidAge = Integer where x >= 0 && x <= 150;

// Record refinement
type ValidUser = { name: String, age: Integer } where isValidUser x;
```

### Constraint Types

```ocaml
// Pattern constraints
type ValidEmail = String with regexp("^[^@]+@[^@]+\\.[^@]+$");
type ValidPhone = String with pattern("\\d{3}-\\d{3}-\\d{4}");

// Value constraints
type NonZero = Integer with x != 0;
type ValidPort = Integer with x > 0 && x <= 65535;

// Multiple constraints
type NonEmptyAlpha = String with regexp("^[A-Za-z]+$") with length > 0;
```

## Common Patterns

### 1. Configuration Management

```ocaml
// Basic configuration
let config = {
    database = {
        host = "localhost",
        port = 5432,
        name = "myapp"
    },
    server = {
        port = 8080,
        host = "0.0.0.0"
    }
};

// Validated configuration
type DatabaseConfig = {
    host: String where length > 0,
    port: Integer where x > 0 && x <= 65535,
    name: String where length > 0
};

type ServerConfig = {
    port: Integer where x > 0 && x <= 65535,
    host: String where length > 0
};

type AppConfig = {
    database: DatabaseConfig,
    server: ServerConfig
};
```

### 2. Data Validation

```ocaml
// User validation
type ValidUser = {
    name: String where length > 0,
    age: Integer where x >= 0 && x <= 150,
    email: String with regexp("^[^@]+@[^@]+\\.[^@]+$")
};

// Validation function
let validateUser = \user ->
    length user.name > 0 &&
    user.age >= 0 &&
    user.age <= 150 &&
    contains "@" user.email;

// Use in refinement type
type ValidUser = { name: String, age: Integer, email: String } where validateUser x;
```

### 3. Error Handling

```ocaml
// Result type for errors
type Result = Success a | Error String;

// Error handling function
let safeDivide = \x y ->
    if y == 0 then
        Error "Division by zero"
    else
        Success (x / y);

// Pattern matching for results
let handleResult = \result ->
    match result of
        Success value => "Success: " ++ toString value,
        Error message => "Error: " ++ message;
```

### 4. Type Classes

```ocaml
// Type class definition
typeclass Show a where
    show: a -> String;

// Instance declarations
instance Show Integer where
    show = \x -> toString x;

instance Show Boolean where
    show = \b -> if b then "true" else "false";

// Constrained function
let print: Show a => a -> String = \x -> "Value: " ++ show x;
```

### 5. Module Organization

```ocaml
// math.lig
module Math;

export let add = \x y -> x + y;
export let multiply = \x y -> x * y;
export type Point = { x: Float, y: Float };

// utils.lig
module Utils;

import { add, multiply } from Math;

export let double = \x -> multiply x 2;
export let sum = \xs -> fold add 0 xs;
```

## Built-in Functions

### Arithmetic

```ocaml
+ : Integer -> Integer -> Integer
- : Integer -> Integer -> Integer
* : Integer -> Integer -> Integer
/ : Integer -> Integer -> Integer
% : Integer -> Integer -> Integer
```

### Comparison

```ocaml
== : a -> a -> Boolean
!= : a -> a -> Boolean
< : Integer -> Integer -> Boolean
<= : Integer -> Integer -> Boolean
> : Integer -> Integer -> Boolean
>= : Integer -> Integer -> Boolean
```

### Logical

```ocaml
&& : Boolean -> Boolean -> Boolean
|| : Boolean -> Boolean -> Boolean
! : Boolean -> Boolean
```

### String

```ocaml
++ : String -> String -> String
toString : Integer -> String
parseInt : String -> Option Integer
length : String -> Integer
```

### List

```ocaml
head : List a -> Option a
tail : List a -> Option (List a)
length : List a -> Integer
append : List a -> List a -> List a
fold : (a -> b -> b) -> b -> List a -> b
map : (a -> b) -> List a -> List b
filter : (a -> Boolean) -> List a -> List a
```

## Advanced Features

### 1. Type-Level Computation

```ocaml
// Type-level functions
type Subtype 'A 'B =
  match ('A, 'B) {
    ('A, 'A) => True,
    (List 'A, List 'B) => Subtype 'A 'B,
    _ => False
  };

// Type-level conditionals
type If 'Cond 'Then 'Else =
  match 'Cond {
    True => 'Then,
    False => 'Else
  };
```

### 2. Pattern Matching with Guards

```ocaml
let classify = \x -> match x {
    n when n > 0 => "positive",
    n when n < 0 => "negative",
    _ => "zero"
};
```

### 3. Record Patterns

```ocaml
let processUser = \user -> match user {
    { name = n, age = a } when a >= 18 => "Adult: " ++ n,
    { name = n, age = a } => "Minor: " ++ n,
    _ => "Unknown user"
};
```

## Common Use Cases

### 1. API Configuration

```ocaml
type ApiConfig = {
    baseUrl: String where length > 0,
    timeout: Integer where x > 0,
    retries: Integer where x >= 0 && x <= 10,
    headers: List { name: String, value: String }
};

let apiConfig = {
    baseUrl = "https://api.example.com",
    timeout = 30,
    retries = 3,
    headers = [
        { name = "Content-Type", value = "application/json" },
        { name = "Authorization", value = "Bearer token" }
    ]
};
```

### 2. Database Schema

```ocaml
type User = {
    id: Integer where x > 0,
    name: String where length > 0,
    email: String with regexp("^[^@]+@[^@]+\\.[^@]+$"),
    age: Integer where x >= 0 && x <= 150,
    active: Boolean
};

type Post = {
    id: Integer where x > 0,
    title: String where length > 0,
    content: String,
    authorId: Integer where x > 0,
    published: Boolean
};
```

### 3. Validation Rules

```ocaml
type ValidationRule = {
    field: String,
    required: Boolean,
    minLength: Option Integer,
    maxLength: Option Integer,
    pattern: Option String
};

let validateField = \rule value ->
    if rule.required && length value == 0 then
        Error "Field is required"
    else if hasValue rule.minLength && length value < getValue rule.minLength then
        Error "Field too short"
    else if hasValue rule.maxLength && length value > getValue rule.maxLength then
        Error "Field too long"
    else
        Success value;
```

## Best Practices

### 1. Use Type Annotations for Clarity

```ocaml
// Good: Clear type annotations
let processUser: User -> String = \user -> user.name;

// Good: Type annotations for complex functions
let validateConfig: Config -> Result Config String = \config ->
    if config.port > 0 then
        Success config
    else
        Error "Invalid port";
```

### 2. Leverage Constraint Types

```ocaml
// Good: Use constraint types for validation
type ValidEmail = String with regexp("^[^@]+@[^@]+\\.[^@]+$");
type ValidPort = Integer where x > 0 && x <= 65535;

// Use constrained types in records
type UserConfig = {
    email: ValidEmail,
    port: ValidPort
};
```

### 3. Organize Code with Modules

```ocaml
// Good: Separate concerns into modules
module Validation;
module Database;
module Api;

// Import what you need
import { validateUser } from Validation;
import { saveUser } from Database;
```

### 4. Use Pattern Matching for Error Handling

```ocaml
// Good: Handle all cases explicitly
let processResult = \result -> match result {
    Success value => "Success: " ++ toString value,
    Error message => "Error: " ++ message
};
```

## Common Pitfalls

### 1. Avoid Recursion Without Termination

```ocaml
// Bad: May not terminate
let rec badFunction = \x -> badFunction x;

// Good: Has termination condition
let rec factorial = \n ->
    if n == 0 then 1 else n * factorial (n - 1);
```

### 2. Use Proper Type Annotations

```ocaml
// Bad: Unclear types
let process = \x -> x + 1;

// Good: Clear type annotations
let process: Integer -> Integer = \x -> x + 1;
```

### 3. Validate Input Data

```ocaml
// Bad: No validation
let createUser = \name age -> { name = name, age = age };

// Good: With validation
let createUser = \name age ->
    if length name > 0 && age >= 0 then
        Success { name = name, age = age }
    else
        Error "Invalid user data";
```

## Quick Reference

### Keywords

```
let, in, fun, type, data, case, of, if, then, else,
import, export, module, typeclass, instance, where,
match, when, Some, None, true, false, rec
```

### Operators

```
+ - * / %     // Arithmetic
== != < <= > >=  // Comparison
&& || !       // Logical
++            // String concatenation
->            // Function arrow
.             // Field access
```

### Type Constructors

```
List a        // List of type a
Option a      // Optional value of type a
Result a b    // Result with success a or error b
{a: T, b: U}  // Record type
A | B         // Union type
```

This reference provides the essential patterns and syntax needed to generate effective Ligature code. The language prioritizes safety, clarity, and validation, making it ideal for configuration management and data validation tasks.
